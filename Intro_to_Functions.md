# INTRO TO FUNCTIONS

## Rule #1 of Notetaking:
    - Relate the new thing to other things in your mind
    - Relate the new thing to the big picture ("why?")

## Rule #2 of Notetaking:
    - Write notes in your own words

## Function: Connected Ideas
    - Procedure, process
    - Routine (repeatable series of steps) / workout habits
    - Sandwich instructions
    - Recipe
    - Algorithm
    - Buttons (press it and it does something)
    - Guide, walkthrough (guiding the computer)
    - Teaching the computer
    - "Machine learning"
    - Jack in the box (an object containing latent behavior which does nothing until triggered)
    - Input and output
    - Automation
    - ARSAW stations
    - RC Sort
    - Badge scanner
    - Problem solving
    - The warehouse ITSELF
      - INPUTS: orders, inbound units, electricity, workers, water, food, office supplies, equipment, money...
      - OUTPUT: outbound packages
    - PRINTER
      - INPUTS/PARAMETER: electricity, paper, ink, document data
      - OUTPUT: printed document
    - Coffee machine
      - INPUTS: coffee grounds, water, electricity(?), time
      - OUTPUT: coffee liquid and waste
    - Humans
    - Keyboards
    - Financial transactions
    - To-do lists

## Function: Big Picture
    - Keep code more organized
    - Help reduce "spaghetti code"
    - Functions can be stored for later and REUSED
    - Prevents repetition (reduces how much code we have to write)
    - Prevents from "reinventing the wheel"
    - Solve a problem or improve a function in ONE place and EVERYWHERE else the function is used gets the benefit


# NOTES from Your Engineering Mind Topic Session on Programming Language Evolution

## What if we didn't have to write all the binary ourselves?
- Solution: Let's create a system of symbols which represent binary and can be assembled together into actual binary machine code!
- *From Machine languages to Assembly languages.*

## What if we could issue more complex commands?
- Solution: Let's create a system, a language, for that!
- *From Assembly languages to Imperative languages.*
- INTRODUCING VARIABLES and complex expressions!

## What if we could create our own custom operators?
- Solution: Let's do that!
- *From Imperative languages to Procedural languages.*
- INTRODUCING FUNCTIONS

## What if we could reduce the jumping around from line to line?
- Solution: Code blocks/scope
- *From Procedural languages to Structured languages.*
- INTRODUCING SCOPE & CODE BLOCKS

